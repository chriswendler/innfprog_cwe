<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drei gewinnt oder Bondesjakk</title>

    <!--
    TIL OPPGAVE 2:
    Et forsøk som ikke fungerte:
    '<style id="mystyle"></style>
    document.getElementById("mystyle").style.backgroundColor = "#FFD700";'' 
    ChatGPT forklarer at <style> ikke er et synlig element som for eksempel <h1> eller <div> er,
    men kun en type definisjon for regler 
    ChatGPT fortalte meg også at  "//" for å kommentere ut kun fungerer i JavaScript, ikke i HTML hvor den her metoden i stedet  
    -->
    <style>
        body {
            background: #ccc;
            font-family: Helvetica;
        }
        
        body>* {
            box-sizing: border-box;
            padding: 0;
            margin: 0;
        }
        
        #playerturn {
            color: #34495e;
            font-size: 3em;
            margin: 20px auto;
            max-width: 600px;
            padding: 10px;
            border-radius: 5px;
        }
        /*
        TIL OPPGAVE 3
        Her måtte jeg høre med ChatGPT om hvordan CSS kunne lenkes til <p>-tagen nedenfor: da tagen ikke inneholder en id
        som playerturn har, kan man ikke bruke #p men skriver bare p. Innholder er i p-CSS er kopiert fra #playerturn, bare 
        skriftstørrelse er endret.
        Varselet kan sikkert unnlates med 1 sekund forinskelse. Den er et produkt av testing med 3000 og 5000 ms. Om den behøvs
        vil være mer et spørsmål for en produktdesigner enn for utvikleren. 
        */
        p{
            color: #34495e;
            font-size: 2em;
            margin: 20px auto;
            max-width: 600px;
            padding: 10px;
            border-radius: 5px;   
        }
        
        #gamearea {
            width: 600px;
            height: 600px;
            margin: 0 auto;
            background-color: #34495e;
            /* OPPGAVE 4: Jeg tentkte først å finne ut hvorfor spillerBrikker er i utgangspunktet hvitet. Jeg spurte ChatGPT
            (Why are the playermarks on the tic tac toe board white?) og ble henvist bl.a. til CSS. Ved gjennomlesning 
            finner jeg denne fargen. Sjekk på https://www.w3schools.com/colors/colors_converter.asp viser at fargen 
            likner veldig på brikkenes farge...  
            */
            color: #fff;
            border: 6px solid #2c3e50;
            border-radius: 10px;
            display: grid;
            /*'Fr' - fracional unit. Skrivet utførlig for bdre forståelse:  */
            grid-template-rows: repeat(3, 1fr);
            grid-template-columns: repeat(3, 1fr);
        }
        
        .celle {
            border: 6px solid #2c3e50;
            border-radius: 2px;
            font-weight: bold;
            font-size: 4em;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #newgame {
            width: 300px;
            padding: 20px;
            display: block;
            margin: 20px auto;
            background: #6ea100;
            border: 2px solid #000;
            border-radius: 5px;
            color: #000;
            font-size: 2rem;
            display: none;
        }
        #newgame:hover {
            background: #364e01;
            color: white;
            cursor: pointer;
        }
    </style>

</head>

<body>
    <section id="playerturn">Spiller <span id="player"></span> (<span id="playermark"></span>) sin tur:</section>
    <!-- TIL OPPGAVE 3: Dette varselet er et produkt av tetsing med lengre enn 1000 ms: -->
    <p>(Du må vente 1 sekund mens vi sjekker om du har vunnet.)</p>
    <!-- https://www.w3schools.com/css/css_grid.asp -->
    <section id="gamearea">
        <div id="celle0" class="celle"></div>
        <div id="celle1" class="celle"></div>
        <div id="celle2" class="celle"></div>
        <div id="celle3" class="celle"></div>
        <div id="celle4" class="celle"></div>
        <div id="celle5" class="celle"></div>
        <div id="celle6" class="celle"></div>
        <div id="celle7" class="celle"></div>
        <div id="celle8" class="celle"></div>
        

    </section>
    <button id="newgame" onclick="restartGame()">Start spill på nytt</button>

    <script>
        var spillStatus = true;
        var player = 1;
        var playermark = "X";

        // Her tror jeg er kommentaren lite upresis ettersom "playerturn" er del av <section>- og ikke av <div>-tagen. 
        // Kommentaren i den opprinnelige filen: 
        // 'Dette skriver vi ut i <span>-tagene med id-ene "player" og "playermark" i <div>-tagen med id "playerturn".'

        document.getElementById("player").innerHTML = player;
        document.getElementById("playermark").innerHTML = playermark;

        var antallSpill = 1;

        var winningCombos = [
            [0, 1, 2],
            [3, 4, 5],
            [6, 7, 8],
            [0, 3, 6],
            [1, 4, 7],
            [2, 5, 8],
            [0, 4, 8],
            [2, 4, 6]
        ];

        var spillerBrikker = ["","","","","","","","",""];

        document.getElementById("celle0").addEventListener("click", function() {
            spill(0);
        });
        document.getElementById("celle1").addEventListener("click", function() {
            spill(1);
        });
        document.getElementById("celle2").addEventListener("click", function() {
            spill(2);
        });
        document.getElementById("celle3").addEventListener("click", function() {
            spill(3);
        });
        document.getElementById("celle4").addEventListener("click", function() {
            spill(4);
        });
        document.getElementById("celle5").addEventListener("click", function() {
            spill(5);
        });
        document.getElementById("celle6").addEventListener("click", function() {
            spill(6);
        });
        document.getElementById("celle7").addEventListener("click", function() {
            spill(7);
        });
        document.getElementById("celle8").addEventListener("click", function() {
            spill(8);
        });

        function spill(celle) {

            // Her oppdaget jeg skrivefeilen uten bruk av konsolen ved å lese gjennom og kopiere deler av koden manuelt (for forståelse)
            if(spillStatus === true) {

                var cellSpace = document.getElementById("celle"+celle).innerHTML;
                
                
                if(cellSpace === "") {
                   
                    if (player === 1) {
                        //dette skjer i nettleseren:
                        document.getElementById("celle"+celle).innerHTML = "X";
                        //og befolke arrayen som holder kontroll på spillbrettet (kun omformulert for å forstå, ingen endring i koden)
                        spillerBrikker[celle] = "X";
                        // OPPGAVE 3: Dette gjøres for å hindre at en spiller plasserer mens vi utsetter sjekk av vinneren: 
                        spillStatus = false;
                    } else {
                        document.getElementById("celle"+celle).innerHTML = "O";
                        spillerBrikker[celle] = "O";
                        spillStatus = false;
                    }

                    // Her stusset jeg, ettersom det er kun '!=' og'!==' som er med i 'Oversikt over sammenligningsoperatorer'i LMS, kapittel 4. 
                    // Med hjelp av ChatGPT fant jeg ut at årsaken at den ikke er med er at den gjør noe (negasjon) mens de andre to bare sammenligner (sjekker om noe er sant)
                    if(!spillerBrikker.includes("")) {
                        document.getElementById("playerturn").innerHTML = "Uavgjort! Ingen vant...";
                        spillStatus = false;
                    }
                    
                /* OPPGAVE 3:
                Her gjorde jeg først en feil og skrev både variablen (const = delay) og
                deretter funksjonen igjen. Resultatet var at funksjonen kjørtes omiddelbart men 
                vinner byttet etter delayen. Ettersom det går an å sette spillmerke uansett delayen 
                (testet med 3000 og 5000 ms), har jeg tatt grep, se nedenfor.
                ChatGPT foreslo også at det er mulig å bygge inn delayen lengre opp, men dette
                hadde vært mer komplisert og krever 3 parametere. (Prompt: 
                in the above longer code, how can i delay the  function spill(celle) execution?)
                */
                const delaySjekkVinner = setTimeout(sjekkVinner, 1000);

                } else {
                    // "Alert" er ikke defintert (Cmd + F) andre steder og jeg trodde først at det dreide seg om en feil.
                    // ChatGpt opplyser likevel at "alert" er definert JS. Etterpå finner jeg samme info også under JS Popup Boxes https://www.w3schools.com/js/js_popup.asp   
                    alert("Denne cellen er opptatt. Vennligst velg en annen celle");
                    return;
                } 
                
                // TIL OPPGAVE 3: Når spillerens tur er ferdig, er det neste spillers tur. For å hindre at man kan
                // sette spillmerket mens vi utsetter, har jeg selv kommet på at man kan flytte ut denne prosessen gjennom
                // en funksjon (på samme måte som sjekkVinner) for å kunne utsette den.     

                const delayChangePlayers = setTimeout(changePlayers, 1000);

            // Hvis spillstatus er false, avslutter vi funksjonen uten å utføre noen handlinger.
            } else {
                return;
            }
        // end of function spill
        }

        function sjekkVinner() {
            var rundenVunnet = false;
            // Vi må sjekke etter vinner for hver brikke som plasseres på brettet.
            // Eksempel: combination 1 gir KomboPlass 3, 4 og 5. Vi sjekker i arrayen som vi har befolket ovenfor. Hvis 3, 4 og 5 alle 
            // alle er "X" (var brikke 1, 2 og 3 er "X"), settes variablen rundenVunnet til true. 
            for(var combination = 0; combination <= 7; combination++) {
                var vinnerKomboPlass1 = winningCombos[combination][0]; //Henter ut plassering av vinnerkombinasjonens rad 1, 
                var vinnerKomboPlass2 = winningCombos[combination][1]; //eksempel winningCombos[0][0] første runde, som inneholder verdien 0.
                var vinnerKomboPlass3 = winningCombos[combination][2]

                var brikke1 = spillerBrikker[vinnerKomboPlass1]; //Henter ut verdien (spillmerket) på indexen til første vinnerkombinasjonsplass fra spillerBrikker, eksempel spillerBrikker[0] første runde.
                var brikke2 = spillerBrikker[vinnerKomboPlass2];
                var brikke3 = spillerBrikker[vinnerKomboPlass3];

                // Her kunne man har brukt if-else men det hadde vært unnødvendig komplisert. 'Continue' betyr: Hvis en plass er
                // ledig, trenger vi ikke sjekke for en vinner-kombinasjon i denne runden av løkken. 
                if(brikke1 === "" || brikke2 === "" || brikke3 === "") {
                    continue;
                }
                //Break: Avbryter løkken 
                if(brikke1 === brikke2 && brikke2 === brikke3) {
                    rundenVunnet = true;
                    break;
                    
                }
            }

            //Hvis runden er vunnet, skal vi gjøre noen handlinger:
            if(rundenVunnet === true) {
                //Skriv ut hvilken spiller som har vunnet
                document.getElementById("playerturn").innerHTML = "Spiller " + player + " har vunnet!";
                //Gjør restart spill-knappen synlig
                document.getElementById("newgame").style.display = "block";

                /*  OPPGAVE 2: ENDRE FARGE
                    Først misforsto jeg oppgavestillingen. Hint viser
                    til 'document.body.style.backgroundColor = "red".' Så jeg skrev:
                    document.body.style.backgroundColor = "#FFD700";
                    Dette hadde også fungert med bare '.background' her, men ifølge ChatGPT er .backroundColor 
                    mer målrettet. 
                    Jeg leste oppgavestillingen igjen og ble usikker og spurte ChatGPT hvordan man kan endre
                    'bakgrunnsfargen i <div> med id playerturn'  
                */

                document.getElementById("playerturn").style.backgroundColor = "#FFD700";
                
                // se kommentar under <style> ovenfor (linje 10) om hvorfor dette ikke fungerer:
                // document.getElementById("mystyle").style.backgroundColor = "#FFD700"; 

                /*
                OPPGAVE 4: Spørsmål til ChatGPT
                1) 'Pls explain this structure: ' .celle '. Why is it called '.celle'. What does ' . ' stand for?'
                Svar (forkortet): .celle er 'class name' Man kunne ha valgt .box eller andre. .celle er også en selector 
                (et utvalgsverktøy?).
                Det er ulike type selectors som class (.celle) og ID (#id)
                2) 'it seems in my code each celle has two selectors,  .celle and #id.' ? [utdrag fra koden]
                Svar : Korrekt.

                Her ser jeg at ID også brukes i eksempel på https://www.w3schools.com/jsref/prop_style_color.asp 
                Jeg forsøker å skrive document.getElementById("celle1").style.color = "FFD700" på ulike plasser i <script>
                og det fungerer.
                */

                spillStatus = false;
            }
        // her slutter sjekkVinner
        }

        // TIL OPPGAVE 3; Vi skal forhindre at man kan sette brikker og at teksten endres mens vi venter på sjekkVinner: 
        function changePlayers() {
        if (player === 1) {
                    player = 2;
                    playermark = "O";
                    spillStatus = true;
                } else {
                    player = 1;
                    playermark = "X";
                    spillStatus = true;
                }
                if(spillStatus === true) {
                    document.getElementById("player").innerHTML = player;
                    document.getElementById("playermark").innerHTML = playermark;
                }}

        function restartGame() {
            // 1)
            spillerBrikker = ["","","","","","","","",""];
            var celleteller = 0;
            while (celleteller < 9) {
                document.getElementById("celle" + celleteller).innerHTML = "";
                celleteller++;
            }
            // 2)
            spillStatus = true;
            // 3)
            player = 1;
            playermark = "X";
            // 4)
            document.getElementById("playerturn").innerHTML = 'Spiller <span id="player">1</span> (<span id="playermark">X</span>) sin tur:';
        }

        
    </script>
</body>

</html>