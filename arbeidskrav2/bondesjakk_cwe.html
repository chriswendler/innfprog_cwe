
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drei gewinnt oder Bondesjakk</title>

    <!--
    TIL OPPGAVE 2:
    Et forsøk som ikke fungerte:
    '<style id="mystyle"></style>
    document.getElementById("mystyle").style.backgroundColor = "#FFD700";'' 
    ChatGPT forklarer at <style> ikke er et synlig element som for eksempel <h1> eller <div> er,
    men kun en type definisjon for regler 
    ChatGPT fortalte meg også at  "//" for å kommentere ut kun fungerer i JavaScript, ikke i HTML hvor den her metoden i stedet  
    -->
    <style>
        body {
            background: #ccc;
            font-family: Helvetica;
        }
        
        body>* {
            box-sizing: border-box;
            padding: 0;
            margin: 0;
        }
        
        #playerturn {
            color: #085fb6;
            font-size: 3em;
            margin: 20px auto;
            max-width: 600px;
            padding: 10px;
            border-radius: 5px;
            background-color: #ccc;
        }
        /*
        TIL OPPGAVE 3
        Her måtte jeg høre med ChatGPT om hvordan CSS kunne lenkes til <p>-tagen nedenfor: da tagen ikke inneholder en id
        som playerturn har, kan man ikke bruke #p men skriver bare p. Innholder er i p-CSS er kopiert fra #playerturn, bare 
        skriftstørrelse er endret.
        Varselet i tagen (se nedenfor) kan sikkert unnlates ved 1 sekund forinskelse. Den er et produkt av testing med 3000 og 5000 ms. Om den behøvs
        vil være mer et spørsmål for en produktdesigner enn for utvikleren. 
        */
        p{
            color: #34495e;
            font-size: 2em;
            margin: 20px auto;
            max-width: 600px;
            padding: 10px;
            border-radius: 5px;   
        }

        #gamearea {
            width: 600px;
            height: 600px;
            margin: 0 auto;
            background-color: #34495e;
            /* OPPGAVE 4: Jeg begynte ved å finne ut hvorfor spillerBrikker er i utgangspunktet hvite. Jeg spurte ChatGPT
            (Why are the playermarks on the tic tac toe board white?) og ble henvist bl.a. til CSS. Ved gjennomlesning 
            finner jeg den hvite fargen her. Sjekket på https://www.w3schools.com/colors/colors_converter.asp 
            */
            color: #fff;
            border: 6px solid #2c3e50;
            border-radius: 10px;
            display: grid;
            /*'Fr' - fracional unit. Skrivet utførlig for bdre forståelse:  */
            grid-template-rows: repeat(3, 1fr);
            grid-template-columns: repeat(3, 1fr);
        }

        .celle {
            border: 6px solid #2c3e50;
            border-radius: 2px;
            font-weight: bold;
            font-size: 4em;
            display: flex;
            justify-content: center;
            align-items: center;
        }

            /*Dette for å utnytte plassen bedre. Gjort på samme måte som i #gamearea ovenfor*/
        #buttonAndBox {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
        }

        /*TIL OPPGAVE 5: En kopi av #newgame med mindre tilpassninger: */
        #spilleTeller {
            width: 300px;
            padding: 20px;
            display: block;
            margin: 20px auto;
            background: #6ea100;
            border: 2px solid #000;
            border-radius: 5px;
            color: #000;
            font-size: 1.5rem;
            /*Jeg kunne først ikke se noen tekst, hverken i eller utenfor span. ChatGPT sier det kan skyldes at dette overstyrres
            (is inherited) men jeg ser heller ikke at visibility brukes andre steder. Det virker å ha løst seg men jeg
            inkluderer for sikkerhets skyld:*/
            visibility: visible; 
        }

        #newgame {
            width: 300px;
            padding: 20px;
            display: block;
            margin: 20px auto;
            background: #6ea100;
            border: 2px solid #000;
            border-radius: 5px;
            color: #000;
            font-size: 2rem;
            display: none;
        }
        #newgame:hover {
            background: #364e01;
            color: white;
            cursor: pointer;
        }
        /*Dette er gjort av interesse fordi jeg ønsket å vite hvordan språkversjonene fungerer. Jeg spurte først ChatGPT
        om hvordan dette gjøres. Deretter tilpasset og forenklet jeg så mye som mulig for å benytte meg av samme type
        struktur og syntax som er brukt i den opprinnelige koden fra kursets repository:*/
        .language-container {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
        }
        .language-button {
            margin-left: auto;
            padding: 10px;
            font-size: 2rem;
            background-color: #6ea100;
            color: white;
            border: none;
            border-radius: 5px;
        }
        .language-button:hover {
            background-color: #364e01; 
            cursor: pointer;         
        }

    </style>

</head>

<body>
    <!--Brukt samme mønster som nedenfor i gamearea. ChatGPT opplyser at de vises ved siden av hverandre 
    og ikke under hverandre da button oppfører seg som 'inline block' hvis ikke annet er definert -->
    <section class="language-container">
        <button class="language-button" onclick="switchLanguage('no')">&#x1f1f3;&#x1f1f4; Norsk</button>
        <button class="language-button" onclick="switchLanguage('de')">&#x1F1E9;&#x1F1EA; Deutsch</button> 
    </section>
    <section id="playerturn">Spiller <span id="player"></span> (<span id="playermark"></span>) sin tur:</section>
    <!-- TIL OPPGAVE 3: Dette varselet er et produkt av tetsing med lengre enn 100 ms: -->
    <p>(Du må vente 1 sekund mens vi sjekker om du har vunnet.)</p>
    <!-- https://www.w3schools.com/css/css_grid.asp -->
    
    <section id="gamearea">
        <div id="celle0" class="celle"></div>
        <div id="celle1" class="celle"></div>
        <div id="celle2" class="celle"></div>
        <div id="celle3" class="celle"></div>
        <div id="celle4" class="celle"></div>
        <div id="celle5" class="celle"></div>
        <div id="celle6" class="celle"></div>
        <div id="celle7" class="celle"></div>
        <div id="celle8" class="celle"></div>
    </section>

    <div id="buttonAndBox">
        <section id="spilleTeller">Du har spilt: <span id="antallSpill"> 0</span> av 3 spill.</section>
        
        <!--Tidligere versjon basert på at man bare teller ferdige spill. Dette var nødvendig da den første deklarasjon
        av variablen var spillteller = 1 sannsynligvis overskrev tellerverdien hver gang. 
        <section id="spilleTeller">Du spiller: <span id="antallSpill">...</span> av 3 spill.</section>  -->
        <button id="newgame" onclick="restartGame()">Start spill på nytt</button>
    </div>


    <script>
        var spillStatus = true;
        var player = 1;
        var playermark = "X";
        // Språkversjonene ligger i en objekt med nøkkel-verdi par hvor no/de er nøkler.
        // Objekten lagres i en variabel.  
        const playerTurnTranslation = {
            no: 'Spiller <span id="player"></span> (<span id="playermark"></span>) sin tur:',
            de: 'Spieler <span id="player"></span> (<span id="playermark"></span>) ist dran:',
        };

        // Her tror jeg er kommentaren lite upresis ettersom "playerturn" er del av <section>- og ikke av <div>-tagen. 
        // Kommentaren i den opprinnelige filen: 
        // 'Dette skriver vi ut i <span>-tagene med id-ene "player" og "playermark" i <div>-tagen med id "playerturn".'

        document.getElementById("player").innerHTML = player;
        document.getElementById("playermark").innerHTML = playermark;

        let antallSpill = 0;

        var winningCombos = [
            [0, 1, 2],
            [3, 4, 5],
            [6, 7, 8],
            [0, 3, 6],
            [1, 4, 7],
            [2, 5, 8],
            [0, 4, 8],
            [2, 4, 6]
        ];

        var spillerBrikker = ["","","","","","","","",""];

        // Dette bare fordi jeg var interessert i å se hvordan man gjør slikt:
        function switchLanguage(lang) {
            document.getElementById("playerturn").innerHTML = playerTurnTranslation[lang];
            //const playerTurnSection = document.getElementById("playerturn");
            //playerTurnSection.innerHTML = playerTurnTranslation[lang];
     
            // Reassign player and playermark values to update in the new language context
            document.getElementById("player").innerHTML = player;
            document.getElementById("playermark").innerHTML = playermark;
             }
        
        // TIL OPPGAVE 5: Etter litt prøving, har jeg landet på a lagre det ut i den egen funksjon. Dette fordi den 
        // skal kalles i to tilfeller, ved uavgjort og ved vunnet. Se også under restart-funkjsionen, som også endrer telleren. 
        function telleSpill() {
            console.log("telleSpill called");
            if(antallSpill <=2) {
                antallSpill++;
            }
            console.log(antallSpill);    
        };
        /*  Dersom man i stedet hadde ønsket å vise "Du spiller X av 3 spill" i spilletelleren, må let antallSpill 
            deklareres til "" i og telleren settes til 1 ved første knappetrykk (første gang spill-funksjonen kjøres):   
                if(antallSpill===""){
                antallSpill=1;
                document.getElementById("antallSpill").innerHTML = antallSpill;
                };
        */  


        

        // Det er her vi begynner å spille ved å utløse funksjonen spill:
        document.getElementById("celle0").addEventListener("click", function() {
            spill(0);
        });
        document.getElementById("celle1").addEventListener("click", function() {
            spill(1);
        });
        document.getElementById("celle2").addEventListener("click", function() {
            spill(2);
        });
        document.getElementById("celle3").addEventListener("click", function() {
            spill(3);
        });
        document.getElementById("celle4").addEventListener("click", function() {
            spill(4);
        });
        document.getElementById("celle5").addEventListener("click", function() {
            spill(5);
        });
        document.getElementById("celle6").addEventListener("click", function() {
            spill(6);
        });
        document.getElementById("celle7").addEventListener("click", function() {
            spill(7);
        });
        document.getElementById("celle8").addEventListener("click", function() {
            spill(8);
        });

        function spill(celle) {

            if(spillStatus === true) {
              
                var cellSpace = document.getElementById("celle"+celle).innerHTML;
                
                if(cellSpace === "") {
                   
                    if (player === 1) {
                    //dette skjer i nettleseren:
                        document.getElementById("celle"+celle).innerHTML = "X";
                    // befolke arrayen som holder kontroll på spillbrettet 
                    // (kommentaren er kun omformulert for å forstå, koden er uendret her):
                        spillerBrikker[celle] = "X";

                    // Dette gjør vi for å forhindre at man kan spille mens vi venter på sjekkVinner. Det er changePlayer 
                    // funksjonen som setter statusen tilbake til "true", se nedenfor:  
                        spillStatus = false;

                    } else {
                        document.getElementById("celle"+celle).innerHTML = "O";
                        spillerBrikker[celle] = "O";
                        spillStatus = false;
                    }

                    // Her stusset jeg, ettersom det er kun '!=' og'!==' som er med i 'Oversikt over sammenligningsoperatorer'i LMS, kapittel 4. 
                    // Med hjelp av ChatGPT fant jeg ut at årsaken at den ikke er med er at den gjør noe (negasjon) mens de andre to bare sammenligner (sjekker om noe er sant)
                    if(!spillerBrikker.includes("")) {
                        document.getElementById("playerturn").innerHTML = "Uavgjort! Ingen vant...";
                        // Dette manglet i den opprinnelige koden fra kursets repository:
                        document.getElementById("newgame").style.display = "inline-block";
                        
                        spillStatus = false;
                        rundenVunnet = false;
                        telleSpill();
                        console.log(antallSpill);
                        document.getElementById("antallSpill").innerHTML = antallSpill;
                        // Dette var nødvendig for å forhindre at changePlayers kjøres:
                        return;
                    }
                    
                /* OPPGAVE 3:
                    Vi utsetter sjekkVinner med 1000 ms etter mønster i W3 schools. Da vi gjør dette bare en gang,
                    og skal heller ikke kansellere, har jeg ikke deklarert en variabel. 
                    (ChatGPT forklarer: å deklarere en variabel kan hjelpe å skrive til konsolen, tracke i real time eller kansellere
                    som i eksemple 2 på https://www.w3schools.com/jsref/met_win_settimeout.asp ).

                    For å forhindre at man kan sette spillmerket mens vi utsetter, har jeg selv kommet på at
                    man kan eksternalisere denne prosessen gjennom
                    en funksjon (på samme måte som sjekkVinner) for å kunne utsette den.     
                    
                    Først trodde jeg at det var nødvendig med en egen Timeout for changePlayer, men ettersom changePlayer kalles av 
                    sjekkVinner, inkludert delayen, er ikke dette nødvendig.
                */
                setTimeout(sjekkVinner, 100);

                } else {
                    // "Alert" er ikke defintert (Cmd + F) andre steder og jeg trodde først at det dreide seg om en feil.
                    // ChatGpt opplyser likevel at "alert" er definert JS. Etterpå finner jeg samme info også under JS Popup Boxes https://www.w3schools.com/js/js_popup.asp   
                    alert("Denne cellen er opptatt. Vennligst velg en annen celle");
                    return;
                // her avsluttes if(cellSpace === "")
                } 

            // Hvis spillstatus er false, avslutter vi funksjonen uten å utføre noen handlinger.
            } else {
                return;
            }
        // end of function spill:
        }

        function sjekkVinner() {
            var rundenVunnet = false;
            // Vi må sjekke etter vinner for hver brikke som plasseres på brettet.
            // Eksempel: combination 1 gir KomboPlass 3, 4 og 5. Vi sjekker i arrayen som vi har befolket ovenfor. Hvis 3, 4 og 5 alle 
            // alle er "X" (var brikke 1, 2 og 3 er "X"), settes variablen rundenVunnet til true. 
            for(var combination = 0; combination <= 7; combination++) {
                var vinnerKomboPlass1 = winningCombos[combination][0]; //Henter ut plassering av vinnerkombinasjonens rad 1, 
                var vinnerKomboPlass2 = winningCombos[combination][1]; //eksempel winningCombos[0][0] første runde, som inneholder verdien 0.
                var vinnerKomboPlass3 = winningCombos[combination][2]

                var brikke1 = spillerBrikker[vinnerKomboPlass1]; //Henter ut verdien (spillmerket) på indexen til første vinnerkombinasjonsplass fra spillerBrikker, eksempel spillerBrikker[0] første runde.
                var brikke2 = spillerBrikker[vinnerKomboPlass2];
                var brikke3 = spillerBrikker[vinnerKomboPlass3];

                // Her kunne man har brukt if-else men det hadde vært unnødvendig komplisert. 'Continue' betyr: Hvis en plass er
                // ledig, trenger vi ikke sjekke for en vinner-kombinasjon i denne runden av løkken. 
                if(brikke1 === "" || brikke2 === "" || brikke3 === "") {
                    continue;
                }
                //Break: Avbryter løkken 
                if(brikke1 === brikke2 && brikke2 === brikke3) {
                    rundenVunnet = true;
                    break;      
                }
            }

            //Hvis runden er vunnet, skal vi gjøre noen handlinger:
            if(rundenVunnet === true) {
                telleSpill();
                document.getElementById("antallSpill").innerHTML = antallSpill;
                //Skriv ut hvilken spiller som har vunnet
                document.getElementById("playerturn").innerHTML = "Spiller " + player + " har vunnet!";
                //Gjør restart spill-knappen synlig
                document.getElementById("newgame").style.display = "inline-block";

                /*  OPPGAVE 2: ENDRE FARGE
                    Først misforsto jeg oppgavestillingen. Hint viser
                    til 'document.body.style.backgroundColor = "red".' Så jeg skrev:
                    document.body.style.backgroundColor = "#FFD700"; som endrer hele bakgrunden. 

                    Jeg leste oppgavestillingen igjen og ble usikker og spurte ChatGPT hvordan man kan endre
                    'bakgrunnsfargen i <div> med id playerturn'  
                    
                    Løsingen nedenfor hadde også fungert med bare '.background' her, men ifølge ChatGPT er .backroundColor 
                    mer målrettet. 
                */

                document.getElementById("playerturn").style.backgroundColor = "#FFD700";
                
                // se kommentar under <style> ovenfor (linje 10) om hvorfor dette ikke fungerer:
                // " document.getElementById("mystyle").style.backgroundColor = "#FFD700"; "  

                /*
                OPPGAVE 4: Spørsmål til ChatGPT
                1) 'Pls explain this structure: ' .celle '. Why is it called '.celle'. What does ' . ' stand for?'
                Svar (forkortet): .celle er 'class name' Man kunne ha valgt .box eller andre navn. " .celle " er også en selektor 
                (et utvalgsverktøy).
                Det er ulike type selectors som f.eks. class (.celle) og ID (#id)
                2) 'it seems in my code each celle has two selectors,  .celle and #id.' ? [utdrag fra koden]
                Svar : Korrekt.

                Her ser jeg at ID også brukes i eksempel på https://www.w3schools.com/jsref/prop_style_color.asp 
                Jeg forsøker å skrive " document.getElementById("celle1").style.color = "FFD700" " på ulike plasser i <script>
                og det fungerer.
                Logikken (egen tenkning):
                vinnerKomboPlass1 viser til et tallverdi som tilsvarer den cellen i arrayen som inneholder brikken i vinnerkombinasjon.
                EksempleL: vinnerkombinasjon er cellene 3,4 og 5. Da er vinnerKomboPlass1 = winningCombos[1][0] som er 3. 
                */

                document.getElementById("celle" + vinnerKomboPlass1).style.color = "#FFD700";
                document.getElementById("celle" + vinnerKomboPlass2).style.color = "#FFD700";
                document.getElementById("celle" + vinnerKomboPlass3).style.color = "#FFD700";

                spillStatus = false;
            } else {
            // else = hvis runden ikke er vunnet
            // ChangePlayer skulle opprinnelig foretas som del av spill-funksjonen. Etter at det ble satt Timeout, førte dette
            // likevel til en feil (uncaught reference 0 ved player i restart Game), som ChatGPT mente kunne skyldes 'scope-related 
            // errors', altså funkjsoner og variabler som defineres innen andre funksjoner. Jeg har løst det ved å ta ut changePlayers
            // av spill. 
            // Det går likevel ikke å sette changePlayer for seg selv etter sjekkVinner. Da fungerer det kun første gang. 
            // Jeg tror årsaken er at spill-funksjonen utløses hver gang man klikker på en celle, så changePlayers må enten vaere 
            // en del av spill eller en annen funksjon som utløses av denne funksjonen.
                
               changePlayers();
            };

        // her slutter sjekkVinner {}:
        }
        
        function changePlayers() {
        if (player === 1) {
                    player = 2;
                    playermark = "O";
                    spillStatus = true;
                } else {
                    player = 1;
                    playermark = "X";
                    spillStatus = true;
                }
                if(spillStatus === true) {
                    document.getElementById("player").innerHTML = player;
                    document.getElementById("playermark").innerHTML = playermark;
                }}

        function restartGame() {
            /* TIL OPPGAVE 5: Etter maks antall spill, skal omstart føre til reset. Det hadde vært mulig å
             telleSpill-funkjsonen utløse omstart, men jeg tror hvis man først viser en knapp for omstart/på nytt,
             så forventer brukeren å beholde kontrollen. 

             Jeg hadde først glemt linjen med document.getElementById og ba ChatGPT om hjelp til debugging. Jeg fikk denne
             veiledning som jeg brukte før jeg oppdaget feilens natur:
            
            function restartGame() {
             console.log("antallSpill before checking condition: ", antallSpill);
                if (antallSpill === 3) {
                 console.log("Condition passed: Resetting antallSpill");
                 antallSpill = 0;
                    } else {
                       console.log("Condition failed: antallSpill is not 3");
                    }
                     console.log("antallSpill after condition: ", antallSpill);
                    }
            */

            if(antallSpill===3) {
                antallSpill = 0
            } 
            document.getElementById("antallSpill").innerHTML = antallSpill;
      
            // TIL OPPGAVE 2: Vi setter fargen av playerturn-section tilbake. For at det fungerer, måtte jeg tilføye  
            // en bakgrundsfare i CSS-blocken ovenfor:
            document.getElementById("playerturn").style.backgroundColor = "#ccc";
            // 1)
            spillerBrikker = ["","","","","","","","",""];
            
            
            var celleteller = 0;
            while (celleteller < 9) {
                document.getElementById("celle" + celleteller).innerHTML = "";

                // TIL OPPGAVE 4: tilbakestill farge - Her har jeg brukt samme mønster som for å fjerne brikkene selv: 
                document.getElementById("celle" + celleteller).style.color = "#fff";
                celleteller++;
            }
            
            spillStatus = true;
            
            player = 1;
            playermark = "X";
            
            document.getElementById("playerturn").innerHTML = 'Spiller <span id="player">1</span> (<span id="playermark">X</span>) sin tur:';

            // her slutter restartGame
         };
                 
    
        
        



    </script>
</body>

</html>
