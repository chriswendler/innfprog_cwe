
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drei gewinnt oder Bondesjakk</title>

    <!--
    TIL OPPGAVE 2:
    Et forsøk som ikke fungerte:
    '<style id="mystyle"></style>
    document.getElementById("mystyle").style.backgroundColor = "#FFD700";'' 
    ChatGPT forklarer at <style> ikke er et synlig element som for eksempel <h1> eller <div> er,
    men kun en type definisjon for regler 
    ChatGPT fortalte meg også at  "//" for å kommentere ut kun fungerer i JavaScript, ikke i HTML hvor den her metoden i stedet  
    -->
    <style>
        body {
            background: #ccc;
            font-family: Helvetica;
        }
        
        body>* {
            box-sizing: border-box;
            padding: 0;
            margin: 0;
        }
        
        #playerturn {
            color: #085fb6;
            font-size: 3em;
            margin: 20px auto;
            max-width: 600px;
            padding: 10px;
            border-radius: 5px;
            background-color: #ccc;
        }
        /*
        TIL OPPGAVE 3
        Her måtte jeg høre med ChatGPT om hvordan CSS kunne lenkes til <p>-tagen nedenfor: da tagen ikke inneholder en id
        som playerturn har, kan man ikke bruke #p men skriver bare p. Innholder er i p-CSS er kopiert fra #playerturn, bare 
        skriftstørrelse er endret.
        Varselet kan sikkert unnlates med 1 sekund forinskelse. Den er et produkt av testing med 3000 og 5000 ms. Om den behøvs
        vil være mer et spørsmål for en produktdesigner enn for utvikleren. 
        */
        p{
            color: #34495e;
            font-size: 2em;
            margin: 20px auto;
            max-width: 600px;
            padding: 10px;
            border-radius: 5px;   
        }
        
        #gamearea {
            width: 600px;
            height: 600px;
            margin: 0 auto;
            background-color: #34495e;
            /* OPPGAVE 4: Jeg tentkte først å finne ut hvorfor spillerBrikker er i utgangspunktet hvitet. Jeg spurte ChatGPT
            (Why are the playermarks on the tic tac toe board white?) og ble henvist bl.a. til CSS. Ved gjennomlesning 
            finner jeg denne fargen. Sjekk på https://www.w3schools.com/colors/colors_converter.asp viser at fargen 
            likner veldig på brikkenes farge...  
            */
            color: #fff;
            border: 6px solid #2c3e50;
            border-radius: 10px;
            display: grid;
            /*'Fr' - fracional unit. Skrivet utførlig for bdre forståelse:  */
            grid-template-rows: repeat(3, 1fr);
            grid-template-columns: repeat(3, 1fr);
        }
        
        #buttonAndBox {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
        }

        .celle {
            border: 6px solid #2c3e50;
            border-radius: 2px;
            font-weight: bold;
            font-size: 4em;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /*TIL OPPGAVE 5: En kopi av #newgame: */
        #spilleTeller {
            width: 300px;
            padding: 20px;
            display: block;
            margin: 20px auto;
            background: #6ea100;
            border: 2px solid #000;
            border-radius: 5px;
            color: #000;
            font-size: 1.5rem;
            /*Jeg kunne først ikke se noen tekst, hverken i eller utenfor span. ChatGPT sier det kan skyldes at dette overstyrres
            (is inherited) men jeg ser heller ikke at visibility brukes andre steder. Det virker å ha løst seg men jeg
            inkluderer for sikkerhets skyld:*/
            visibility: visible; 
        }

        #newgame {
            width: 300px;
            padding: 20px;
            display: block;
            margin: 20px auto;
            background: #6ea100;
            border: 2px solid #000;
            border-radius: 5px;
            color: #000;
            font-size: 2rem;
            display: none;
        }
        #newgame:hover {
            background: #364e01;
            color: white;
            cursor: pointer;
        }

        .language-container {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
        }
        .language-button {
            margin-left: auto;
            padding: 10px;
            font-size: 2rem;
            background-color: #6ea100;
            color: white;
            border: none;
            border-radius: 5px;
        }
        .language-button:hover {
            background-color: #364e01; 
            cursor: pointer;         
        }

    </style>

</head>

<body>
    <div class="language-container">
        <button class="language-button" onclick="switchLanguage('no')">&#x1f1f3;&#x1f1f4; Norsk</button>
        <button class="language-button" onclick="switchLanguage('de')">&#x1F1E9;&#x1F1EA; Deutsch</button> 
    </div>
    <section id="playerturn">Spiller <span id="player"></span> (<span id="playermark"></span>) sin tur:</section>
    <!-- TIL OPPGAVE 3: Dette varselet er et produkt av tetsing med lengre enn 1000 ms: -->
    <p>(Du må vente 1 sekund mens vi sjekker om du har vunnet.)</p>
    <!-- https://www.w3schools.com/css/css_grid.asp -->
    <section id="gamearea">
        <div id="celle0" class="celle"></div>
        <div id="celle1" class="celle"></div>
        <div id="celle2" class="celle"></div>
        <div id="celle3" class="celle"></div>
        <div id="celle4" class="celle"></div>
        <div id="celle5" class="celle"></div>
        <div id="celle6" class="celle"></div>
        <div id="celle7" class="celle"></div>
        <div id="celle8" class="celle"></div>
        
    
    </section>
    <div id="buttonAndBox">
        <section id="spilleTeller">Du spiller: <span id="antallSpill">...</span> av 3 spill.</section>
        <!--Tidligere versjon basert på at man bare teller ferdige spill. Dette var nødvendig da den første deklarasjon
        av variablen var spillteller = 1 sannsynligvis overskrev tellerverdien hver gang. 
        <section id="spilleTeller">Du har spilt: <span id="antallSpill"> 0</span> spill.</section>  -->
        <button id="newgame" onclick="restartGame()">Start spill på nytt</button>
    </div>


    <script>
        var spillStatus = true;
        var player = 1;
        var playermark = "X";
        // Dette bare fordi jeg var interessert i å se hvordan man gjør slikt. Språkversjonene 
        // ligger i en objekt med nøkkel-verdi par hvor no/de er nøkler. Objekten lagres i en variabel.  
        const playerTurnTranslation = {
            no: 'Spiller <span id="player"></span> (<span id="playermark"></span>) sin tur:',
            de: 'Spieler <span id="player"></span> (<span id="playermark"></span>) ist dran:',
        };

        // Her tror jeg er kommentaren lite upresis ettersom "playerturn" er del av <section>- og ikke av <div>-tagen. 
        // Kommentaren i den opprinnelige filen: 
        // 'Dette skriver vi ut i <span>-tagene med id-ene "player" og "playermark" i <div>-tagen med id "playerturn".'

        document.getElementById("player").innerHTML = player;
        document.getElementById("playermark").innerHTML = playermark;

        let antallSpill = "";

        var winningCombos = [
            [0, 1, 2],
            [3, 4, 5],
            [6, 7, 8],
            [0, 3, 6],
            [1, 4, 7],
            [2, 5, 8],
            [0, 4, 8],
            [2, 4, 6]
        ];

        var spillerBrikker = ["","","","","","","","",""];

        // Dette bare fordi jeg var interessert i å se hvordan man gjør slikt:
        function switchLanguage(lang) {
            document.getElementById("playerturn").innerHTML = playerTurnTranslation[lang];
            //const playerTurnSection = document.getElementById("playerturn");
            //playerTurnSection.innerHTML = playerTurnTranslation[lang];
     
                    // Reassign player and playermark values to update in the new language context
            document.getElementById("player").innerHTML = player;
            document.getElementById("playermark").innerHTML = playermark;
             }

        document.getElementById("celle0").addEventListener("click", function() {
            spill(0);
        });
        document.getElementById("celle1").addEventListener("click", function() {
            spill(1);
        });
        document.getElementById("celle2").addEventListener("click", function() {
            spill(2);
        });
        document.getElementById("celle3").addEventListener("click", function() {
            spill(3);
        });
        document.getElementById("celle4").addEventListener("click", function() {
            spill(4);
        });
        document.getElementById("celle5").addEventListener("click", function() {
            spill(5);
        });
        document.getElementById("celle6").addEventListener("click", function() {
            spill(6);
        });
        document.getElementById("celle7").addEventListener("click", function() {
            spill(7);
        });
        document.getElementById("celle8").addEventListener("click", function() {
            spill(8);
        });

        function spill(celle) {



            if(spillStatus === true) {

                if(antallSpill===""){
                antallSpill=1;
                document.getElementById("antallSpill").innerHTML = antallSpill;
            };

                var cellSpace = document.getElementById("celle"+celle).innerHTML;
                
                
                if(cellSpace === "") {
                   
                    if (player === 1) {
                        //dette skjer i nettleseren:
                        document.getElementById("celle"+celle).innerHTML = "X";
                        //og befolke arrayen som holder kontroll på spillbrettet (kun omformulert for å forstå, ingen endring i koden)
                        spillerBrikker[celle] = "X";
                        // OPPGAVE 3: Dette gjøres for å hindre at en spiller plasserer mens vi utsetter sjekk av vinneren: 
                        spillStatus = false;
                    } else {
                        document.getElementById("celle"+celle).innerHTML = "O";
                        spillerBrikker[celle] = "O";
                        spillStatus = false;
                    }

                    // Her stusset jeg, ettersom det er kun '!=' og'!==' som er med i 'Oversikt over sammenligningsoperatorer'i LMS, kapittel 4. 
                    // Med hjelp av ChatGPT fant jeg ut at årsaken at den ikke er med er at den gjør noe (negasjon) mens de andre to bare sammenligner (sjekker om noe er sant)
                    if(!spillerBrikker.includes("")) {
                        document.getElementById("playerturn").innerHTML = "Uavgjort! Ingen vant...";
                        // Dette manglet i den opprinnelige koden fra kursets repository:
                        document.getElementById("newgame").style.display = "inline-block";
                        spillStatus = false;
                    }
                    
                /* OPPGAVE 3:
                Her gjorde jeg først en feil og skrev både variablen (const = delay) og
                deretter funksjonen igjen. Resultatet var at funksjonen kjørtes omiddelbart men 
                vinner byttet etter delayen. Ettersom det går an å sette spillmerke uansett delayen 
                (testet med 3000 og 5000 ms), har jeg tatt grep, se nedenfor.
                ChatGPT foreslo også at det er mulig å bygge inn delayen lengre opp, men dette
                hadde vært mer komplisert og krever 3 parametere. (Prompt: 
                in the above longer code, how can i delay the  function spill(celle) execution?)
                */
                setTimeout(sjekkVinner, 1000);

                } else {
                    // "Alert" er ikke defintert (Cmd + F) andre steder og jeg trodde først at det dreide seg om en feil.
                    // ChatGpt opplyser likevel at "alert" er definert JS. Etterpå finner jeg samme info også under JS Popup Boxes https://www.w3schools.com/js/js_popup.asp   
                    alert("Denne cellen er opptatt. Vennligst velg en annen celle");
                    return;
                } 
                
                // TIL OPPGAVE 3: Når spillerens tur er ferdig, er det neste spillers tur. For å hindre at man kan
                // sette spillmerket mens vi utsetter, har jeg selv kommet på at man kan flytte ut denne prosessen gjennom
                // en funksjon (på samme måte som sjekkVinner) for å kunne utsette den.     

            // Hvis spillstatus er false, avslutter vi funksjonen uten å utføre noen handlinger.
            } else {
                return;
            }
        // end of function spill
        }

        function sjekkVinner() {
            var rundenVunnet = false;
            // Vi må sjekke etter vinner for hver brikke som plasseres på brettet.
            // Eksempel: combination 1 gir KomboPlass 3, 4 og 5. Vi sjekker i arrayen som vi har befolket ovenfor. Hvis 3, 4 og 5 alle 
            // alle er "X" (var brikke 1, 2 og 3 er "X"), settes variablen rundenVunnet til true. 
            for(var combination = 0; combination <= 7; combination++) {
                var vinnerKomboPlass1 = winningCombos[combination][0]; //Henter ut plassering av vinnerkombinasjonens rad 1, 
                var vinnerKomboPlass2 = winningCombos[combination][1]; //eksempel winningCombos[0][0] første runde, som inneholder verdien 0.
                var vinnerKomboPlass3 = winningCombos[combination][2]

                var brikke1 = spillerBrikker[vinnerKomboPlass1]; //Henter ut verdien (spillmerket) på indexen til første vinnerkombinasjonsplass fra spillerBrikker, eksempel spillerBrikker[0] første runde.
                var brikke2 = spillerBrikker[vinnerKomboPlass2];
                var brikke3 = spillerBrikker[vinnerKomboPlass3];

                // Her kunne man har brukt if-else men det hadde vært unnødvendig komplisert. 'Continue' betyr: Hvis en plass er
                // ledig, trenger vi ikke sjekke for en vinner-kombinasjon i denne runden av løkken. 
                if(brikke1 === "" || brikke2 === "" || brikke3 === "") {
                    continue;
                }
                //Break: Avbryter løkken 
                if(brikke1 === brikke2 && brikke2 === brikke3) {
                    rundenVunnet = true;
                    break;      
                }
            }

            //Hvis runden er vunnet, skal vi gjøre noen handlinger:
            if(rundenVunnet === true) {
                //Skriv ut hvilken spiller som har vunnet
                document.getElementById("playerturn").innerHTML = "Spiller " + player + " har vunnet!";
                //Gjør restart spill-knappen synlig
                document.getElementById("newgame").style.display = "inline-block";

                /*  OPPGAVE 2: ENDRE FARGE
                    Først misforsto jeg oppgavestillingen. Hint viser
                    til 'document.body.style.backgroundColor = "red".' Så jeg skrev:
                    document.body.style.backgroundColor = "#FFD700";
                    Løsingen nedenfor hadde også fungert med bare '.background' her, men ifølge ChatGPT er .backroundColor 
                    mer målrettet. 
                    Jeg leste oppgavestillingen igjen og ble usikker og spurte ChatGPT hvordan man kan endre
                    'bakgrunnsfargen i <div> med id playerturn'  
                */

                document.getElementById("playerturn").style.backgroundColor = "#FFD700";
                
                // se kommentar under <style> ovenfor (linje 10) om hvorfor dette ikke fungerer:
                // document.getElementById("mystyle").style.backgroundColor = "#FFD700"; 

                /*
                OPPGAVE 4: Spørsmål til ChatGPT
                1) 'Pls explain this structure: ' .celle '. Why is it called '.celle'. What does ' . ' stand for?'
                Svar (forkortet): .celle er 'class name' Man kunne ha valgt .box eller andre. .celle er også en selector 
                (et utvalgsverktøy?).
                Det er ulike type selectors som class (.celle) og ID (#id)
                2) 'it seems in my code each celle has two selectors,  .celle and #id.' ? [utdrag fra koden]
                Svar : Korrekt.

                Her ser jeg at ID også brukes i eksempel på https://www.w3schools.com/jsref/prop_style_color.asp 
                Jeg forsøker å skrive document.getElementById("celle1").style.color = "FFD700" på ulike plasser i <script>
                og det fungerer.
                vinnerKomboPlass1 viser til et tallverdi som tilsvarer den cellen i arrayen som inneholder brikken i vinnerkombinasjon.
                EksempleL: vinnerkombinasjon er cellene 3,4 og 5. Da er vinnerKomboPlass1 = winningCombos[1][0] som er 3. 
                */

                document.getElementById("celle" + vinnerKomboPlass1).style.color = "#FFD700";
                document.getElementById("celle" + vinnerKomboPlass2).style.color = "#FFD700";
                document.getElementById("celle" + vinnerKomboPlass3).style.color = "#FFD700";

                spillStatus = false;
            } else {
            // else = hvis runden ikke er vunnet
            // Change player skulle opprinnelig foretas som del av spill-funksjonen. Etter at det ble satt Timeout, førte dette
            // likevel til en feil (uncaught reference 0 ved player i restart Game), som ChatGPT mente kunne skyldes 'scope-related 
            // errors', altså funkjsoner og variabler som defineres innen andre funksjoner. Jeg har løst det ved å ta ut changePlayers
            // av spill. Det går likevel ikke å sette change player for seg selv etter sjekkVinner.  
                setTimeout(changePlayers, 1000);
            };
        // her slutter sjekkVinner:
        }

        // TIL OPPGAVE 3; Vi skal forhindre at man kan sette brikker og at teksten endres mens vi venter på sjekkVinner: 
        function changePlayers() {
        if (player === 1) {
                    player = 2;
                    playermark = "O";
                    spillStatus = true;
                } else {
                    player = 1;
                    playermark = "X";
                    spillStatus = true;
                }
                if(spillStatus === true) {
                    document.getElementById("player").innerHTML = player;
                    document.getElementById("playermark").innerHTML = playermark;
                }}

        function restartGame() {
            rundenVunnet = false;
            document.getElementById("playerturn").style.backgroundColor = "#ccc";
            // 1)
            spillerBrikker = ["","","","","","","","",""];
            
            
            var celleteller = 0;
            while (celleteller < 9) {
                document.getElementById("celle" + celleteller).innerHTML = "";
                // TIL OPPGAVE 4: Her har jeg brukt samme mønster som for å fjerne brikkene: 
                document.getElementById("celle" + celleteller).style.color = "#fff";
                celleteller++;
            }
            // 2)
            spillStatus = true;
            // 3)
            player = 1;
            playermark = "X";
            // 4)
            document.getElementById("playerturn").innerHTML = 'Spiller <span id="player">1</span> (<span id="playermark">X</span>) sin tur:';
            // 5) Antall spill
                if(antallSpill <= 2) {
                antallSpill++;
                document.getElementById("antallSpill").innerHTML = antallSpill;
                    } else {
                // if-else er min egen påfunn for ikke å telle i det uendelige. Men jeg måtte spørre ChatGPT hvorfor 
                // man må klikke 2x for å sette tilbake til null. Forklaringen i mine egne ord: Det var
                // egentlig ikke nødvendig å klikke 2 ganger. Variablen var satt tilbake til 0 allerede.
                // Men den andre klikken gjorde at første delen av if else kjørtes igjen (med antallSpill <= 3 sant) 
                // og document.getElementbyId oppdaterte displayen.
                // Om man har med document.getElementById linjer endrer på ingen måte spillens logikk. 
                antallSpill = "";
                document.getElementById("antallSpill").innerHTML = antallSpill;
                console.log(antallSpill);
                
                 };
    
        // her slutter restartGame
        }



    </script>
</body>

</html>
